1-1 For which reason is it better to run the container with a flag -e to give the environment variables rather than put them directly in the Dockerfile? 

Answer: it's better to run the container with a flag -e rather than putting them in the Dockerfile for privacy and confidentiality concerns. Anyone can access the image and see the Dockerfile but they can't access the environment variables given at runtime.

1-2 Why do we need a volume to be attached to our postgres container?

Answer: We must attached a volume to our postgres container in order to create data persistence outside the container, if somehow the container is deleted, then thanks to written data on the host machine, it can retrieve data although the container is deleted.

1-3 Document your database container essentials: commands and Dockerfile.

# Use the official PostgreSQL image as a base
FROM postgres:16

# Define environment variables (custom default configuration)
ENV POSTGRES_DB=db \
    POSTGRES_USER=usr \
    POSTGRES_PASSWORD=pwd

# Copy initialization SQL scripts into the special directory
COPY CreateScheme.sql /docker-entrypoint-initdb.d/
COPY InsertData.sql /docker-entrypoint-initdb.d/

# Build the image
docker build -t efrei-postgres .

# Run the container
docker run --network app-network -d \
  --name db \
  -p 5432:5432 \
  -v "$(pwd)/data:/var/lib/postgresql/data" \
  efrei-postgres

# Create a network to allow connections between containers (PostgreSQL image and adminer)

# Run adminer to see and manage the db
docker run -d --network app-network \
  --name adminer \
  -p 8080:8080 \
  adminer

1-4 Why do we need a multistage build? And explain each step of this dockerfile.

We need a multistage build to separate the build process of our java application from the runtime environment.

# FROM eclipse-temurin:21-jdk-alpine AS myapp-build
Use a small Linux image that already has Java 21 (JDK) installed.

# ENV MYAPP_HOME=/opt/myapp
  WORKDIR $MYAPP_HOME
Create a folder /opt/myapp inside the container and work inside it.

# RUN apk add --no-cache maven
Install Maven, the tool that builds our Java project and creates the .jar file.

# COPY pom.xml .
  COPY src ./src
Copy our project files (the pom.xml and src/ folder) from our computer into the container.

# RUN mvn package -DskipTests
Run Maven to build the app and create a .jar file in /opt/myapp/target/.

# FROM eclipse-temurin:21-jre-alpine
Start a new, smaller image that has only the Java Runtime (JRE).

# ENV MYAPP_HOME=/opt/myapp
	WORKDIR $MYAPP_HOME
Create the same working folder again in this new container.

# COPY --from=myapp-build $MYAPP_HOME/target/*.jar $MYAPP_HOME/myapp.jar
Copy only the built JAR file from the previous build container into this clean runtime container.

# ENTRYPOINT ["java", "-jar", "myapp.jar"]
Tell Docker how to start the app

1-5 Why do we need a reverse proxy?

We need a reverse proxy to keep our back-end hidden and secured, in fact, thanks to a reverse proxy, also compared as the middleware between the user and the back-end, it allow users to request data from a unique entry point. The reverse proxy will first capture the user request and according to its request transfer it to its appropriate back-end service. Once, it has retrived, it will send it back to the user.
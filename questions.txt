1-1 For which reason is it better to run the container with a flag -e to give the environment variables rather than put them directly in the Dockerfile? 

Answer: it's better to run the container with a flag -e rather than putting them in the Dockerfile for privacy and confidentiality concerns. Anyone can access the image and see the Dockerfile but they can't access the environment variables given at runtime.

1-2 Why do we need a volume to be attached to our postgres container?

Answer: We must attached a volume to our postgres container in order to create data persistence outside the container, if somehow the container is deleted, then thanks to written data on the host machine, it can retrieve data although the container is deleted.

1-3 Document your database container essentials: commands and Dockerfile.

# Use the official PostgreSQL image as a base
FROM postgres:16

# Define environment variables (custom default configuration)
ENV POSTGRES_DB=db \
    POSTGRES_USER=usr \
    POSTGRES_PASSWORD=pwd

# Copy initialization SQL scripts into the special directory
COPY CreateScheme.sql /docker-entrypoint-initdb.d/
COPY InsertData.sql /docker-entrypoint-initdb.d/

# Build the image
docker build -t efrei-postgres .

# Run the container
docker run --network app-network -d \
  --name db \
  -p 5432:5432 \
  -v "$(pwd)/data:/var/lib/postgresql/data" \
  efrei-postgres

# Create a network to allow connections between containers (PostgreSQL image and adminer)

# Run adminer to see and manage the db
docker run -d --network app-network \
  --name adminer \
  -p 8080:8080 \
  adminer

1-4 Why do we need a multistage build? And explain each step of this dockerfile.

We need a multistage build to separate the build process of our java application from the runtime environment.

# FROM eclipse-temurin:21-jdk-alpine AS myapp-build
Use a small Linux image that already has Java 21 (JDK) installed.

# ENV MYAPP_HOME=/opt/myapp
  WORKDIR $MYAPP_HOME
Create a folder /opt/myapp inside the container and work inside it.

# RUN apk add --no-cache maven
Install Maven, the tool that builds our Java project and creates the .jar file.

# COPY pom.xml .
  COPY src ./src
Copy our project files (the pom.xml and src/ folder) from our computer into the container.

# RUN mvn package -DskipTests
Run Maven to build the app and create a .jar file in /opt/myapp/target/.

# FROM eclipse-temurin:21-jre-alpine
Start a new, smaller image that has only the Java Runtime (JRE).

# ENV MYAPP_HOME=/opt/myapp
	WORKDIR $MYAPP_HOME
Create the same working folder again in this new container.

# COPY --from=myapp-build $MYAPP_HOME/target/*.jar $MYAPP_HOME/myapp.jar
Copy only the built JAR file from the previous build container into this clean runtime container.

# ENTRYPOINT ["java", "-jar", "myapp.jar"]
Tell Docker how to start the app

1-5 Why do we need a reverse proxy?

We need a reverse proxy to keep our back-end hidden and secured, in fact, thanks to a reverse proxy, also compared as the middleware between the user and the back-end, it allow users to request data from a unique entry point. The reverse proxy will first capture the user request and according to its request transfer it to its appropriate back-end service. Once, it has retrived, it will send it back to the user.

1-6 Why is docker-compose so important?

Docker Compose is important because it allows you to define and run multiple containers easily using a single configuration file (docker‑compose.yml) and command.

1-7 Document docker-compose most important commands

docker compose up	Start all services defined in the docker‑compose.yml file
docker compose up -d	Start in detached mode (in background)
docker compose up --build	Build images before starting containers
docker compose down	Stop and remove the containers, network, and default resources
docker compose stop	Pause the running containers without removing them
docker compose start	Restart previously stopped containers
docker compose ps	List all containers currently managed by the compose file
docker compose logs -f	Display real‑time logs for all services
docker compose build	(Re)build all images defined in the compose file

1-8 Document your docker-compose.yml file 

version: "3.8"

services:
  # Backend - Spring Boot application
  backend:
    build: ./DockerfileSimpleApi
    container_name: simpleapi
    ports:
      - "8080:8080"
    depends_on:
      - database
    networks:
      - app-network-v2

  # Database - PostgreSQL
  database:
    image: postgres:14
    container_name: db
    environment:
      POSTGRES_USER: simpleapi
      POSTGRES_PASSWORD: simpleapi
      POSTGRES_DB: simpleapi
    volumes:
      - db-data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - app-network-v2

  # HTTP server / Reverse proxy - Nginx
  httpd:
    build: ./DockerfileHttpServer
    container_name: nginx-proxy
    ports:
      - "80:80"
    depends_on:
      - backend
    networks:
      - app-network-v2

# Define existing custom network
networks:
  app-network-v2:
    external: true

# Data persistence for PostgreSQL
volumes:
  db-data:

1-9 Document your publication commands and published images in Docker Hub

# Log in to your Docker Hub account
docker login

# Tag the backend image
docker tag efrei_docker-backend leanpenhchakrithchea/simpleapi:1.0

# Push the backend image
docker push leanpenhchakrithchea/simpleapi:1.0

# Tag the reverse proxy (Nginx) image
docker tag efrei_docker-httpd leanpenhchakrithchea/nginx-proxy:1.0

# Push your reverse proxy image
docker push leanpenhchakrithchea/nginx-proxy:1.0

1-10 Why do we put our images into an online repo?

So they can be shared, reused and deployed from anywhere.